

    gpio_config_t UILedPins_conf = {};
    esp_err_t err;

    // Two standalone red leds,
    // transistor switched via MCU
    //setupUILedPins(&UILedPins_conf);

    typedef enum {
    none,
    noteOn,
    noteOff
}   midiEventType_t;

typedef struct 
{

    rgbLedColour_t colour;
    uint8_t velocity;
    uint8_t note;
    midiEventType_t eventType;
    uint8_t paramByte1;
    uint8_t paramByte2;

} midiGridData_t;



        uint8_t data[10];
        memset(data, 0x55, 10);

        fileSys_openFileRW("mrBeefy.MIDI", true);
        fileSys_writeFile(data, 10, false);
        fileSys_resetFilePtr();
        fileSys_readFile(psramFileBuffer, fileSysInfo->numBytesInOpenFile);

        for(uint16_t i = 0; i < fileSysInfo->numBytesInOpenFile; ++i)
        {
            ESP_LOGI(LOG_TAG, "Byte[%d]: %0x", i, psramFileBuffer[i]);
        }

        fileSys_closeFile();



    if(demoTestPlaybackPrepareFile(fileSysInfo, midiFileDataCache) !=0)
    {
        ESP_LOGE(LOG_TAG, "Failed to prepare test playback data");
        while(1)
        {
            ESP_LOGE(LOG_TAG, "SYSTEM FAULT");
            vTaskDelay(pdMS_TO_TICKS(3000));
        }
    }

    vTaskDelay(1);

    if(midi_loadMidiFile(midiFileDataCache) != 0)
    {
        ESP_LOGE(LOG_TAG, "Failed to load midi file");
        while(1)
        {
            ESP_LOGE(LOG_TAG, "SYSTEM FAULT");
            vTaskDelay(pdMS_TO_TICKS(3000));
        }
    }



    void bleTestProcess(void)
{
    appToBleQueueItem_t bleData;
    switchEventQueueItem_t switchMatrixQueueItem = {0};    


    if (xQueueReceive(switchMatrixEventQueue, &switchMatrixQueueItem, 0) == pdTRUE)
    {

        bleData.dataLength = midi_getMidiTrackLength();
        bleData.opcode = 0x55;
        bleData.dataPtr = midiFileDataCache + 22;

        if(xQueueSend(appToBleQueue, &bleData, 10) != pdTRUE)
        {
            ESP_LOGE(LOG_TAG, "FAILED TO SEND FROM APP TO BLE QUEUE");
        }

        /*bleData.opcode = 1;
        if(xQueueSend(appToBleQueue, &bleData, 10) != pdTRUE)
        {
            ESP_LOGE(LOG_TAG, "FAILED TO SEND FROM APP TO BLE QUEUE");
        }*/
    }
}


static uint8_t demoTestPlaybackPrepareFile(fileSysInterfaceData_t * fileSysInterfacePtr, uint8_t * fileDataCache)
{
    //Plays back the first midi track found on the file system.
    //We can flash the file sys over USB and test file based playback.
    if(fileSys_openFileRW(&fileSysInterfacePtr->fileNamesPtr[0][0], false) == 0)
    {
        ESP_LOGI(LOG_TAG, "Sucessfully opened file: %s", &fileSysInterfacePtr->fileNamesPtr[0][0]);
    }
    else
    {
        ESP_LOGE(LOG_TAG, "Failed to open file: %s", &fileSysInterfacePtr->fileNamesPtr[0][0]);
        return 1;
    }

    if(fileSys_readFile(fileDataCache, fileSysInterfacePtr->numBytesInOpenFile) == 0)
    {
        ESP_LOGI(LOG_TAG, "Sucessfully read: %ld bytes into local PSRAM cache", fileSysInterfacePtr->numBytesInOpenFile);
    }
    else
    {
        ESP_LOGE(LOG_TAG, "Failed to read %ld bytes", fileSysInterfacePtr->numBytesInOpenFile);
        return 1;
    }

    return 0;
}




uint8_t gridDataToMidiFile(uint8_t * fileBuffer);
void updateGridLEDs(uint8_t rowOffset, uint16_t columnOffset);
static uint32_t getMidiDeltaTime(uint8_t **deltaTimeBase);
inline static sequencerGridItem_t * createNewGridItem(const sequencerGridItem_t * const prevPtr);
static uint8_t appendNewGridItemToRow(uint8_t midiNoteNum);
static uint16_t deltaTimeToColumnOffset(uint32_t deltaTime);
static uint8_t processMetaMessage(uint8_t **midiFilePtr);
static void freePreviousGridData(void);

sequencerGridData_t sequencerGridData;

uint8_t *filePtr;

#define TEMPO_IN_MICRO 500000


uint8_t initSequencerGrid()
{
    memset(&sequencerGridData, 0, sizeof(sequencerGridData));
    return 0;
}


uint8_t startNewProject(uint8_t ppqn)
{
    freePreviousGridData();

    return 0;
}




uint8_t gridDataToMidiFile(uint8_t * fileBuffer) //add size and make sure will fit or abort
{
    uint32_t deltaTime;
    uint32_t numItemsSaved = 0;
    uint8_t tempDeltaTime;
    uint8_t deltaTimeNumBytes;
    uint8_t * trackChunkBase = fileBuffer;
    sequencerGridItem_t * tempGridItemPtr = NULL;

    if(fileBuffer == NULL) return 1; //Abort

    //Write the TRACK HEADER 
    for(uint8_t a = 0; a < MIDI_TRACK_HEADER_NUM_BYTES; ++a)
    {
        *fileBuffer = MTtk_trackHeaderBytes[a];
        ++fileBuffer;
    }

    //Write the CHUNK SIZE (length of following track data)
    for(int8_t a = (MIDI_FILE_TRACK_CHUNK_SIZE_NUM_BYTES-1); a >= 0 ; --a)
    {
        *fileBuffer =  (uint8_t)(sequencerGridData.midiDataNumBytes >> (a * 8));
        ++fileBuffer;
    }


    //Cycle through all rows and columns of the 
    //linked list that holds all the runtime grid data
    for(uint16_t currentTargetColumn = 0; currentTargetColumn <= sequencerGridData.totalGridColumns; ++currentTargetColumn)
    {

        for(uint8_t currentRow = 0; currentRow < 128; ++currentRow)
        {   

            if(sequencerGridData.gridData[currentRow] != NULL)  //skip row if nothing allocated
            {

                tempGridItemPtr = sequencerGridData.gridData[currentRow];

                //Search the current row for any events which
                //exists within the target grid column
                while(tempGridItemPtr->column < currentTargetColumn)
                {
                    if(tempGridItemPtr->nextPtr == NULL) goto next;
                    tempGridItemPtr = tempGridItemPtr->nextPtr;
                }

                if(tempGridItemPtr->column != currentTargetColumn) goto next;

                ESP_LOGI(LOG_TAG, "Column num: %d", currentTargetColumn);
                ESP_LOGI(LOG_TAG, "Item Colum: %d", tempGridItemPtr->column);
                ESP_LOGI(LOG_TAG, "Note num: %0x", currentRow);

                //If we reached here, that means that the current
                //target row x column grid co-orintate exists
                //The target grid event will now be added to the 
                //midi file track chunk currenrly being constructed

                numItemsSaved++;
                deltaTime = tempGridItemPtr->deltaTime;

                tempDeltaTime = deltaTime & 0x7F;

                while (deltaTime >>= 7)
                {
                    tempDeltaTime <<= 8;
                    tempDeltaTime |= ((deltaTime & 0x7F) | 0x80);
                }

                while (1)
                {
                    *fileBuffer = tempDeltaTime;
                    ++fileBuffer;
                    if(tempDeltaTime & 0x80) tempDeltaTime >>= 8;
                    else break;
                }

                ESP_LOGI(LOG_TAG, "********** Event written *********");

                *fileBuffer = tempGridItemPtr->statusByte; //status
                ++fileBuffer;
                *fileBuffer = tempGridItemPtr->dataBytes[0]; //note num
                ++fileBuffer;
                *fileBuffer = tempGridItemPtr->dataBytes[1]; //velocity
                ++fileBuffer;
            }
            next:
        }
    }

    ESP_LOGI(LOG_TAG, "Saved %ld grid items to file", numItemsSaved);
    for(uint8_t a = 0; a < 100; ++a)
    {
        ESP_LOGI(LOG_TAG, "Data[%d] = %0x", a, trackChunkBase[a]);
    }


    //We need to add the end of track meta message
    //This is used by the sequencer throughout 
    //0xff 0x2f 0x00

    return 0;
}


//also use this to start new file automatically?
uint8_t midiFileToGrid(uint8_t * midiFileDataPtr)
{
    //This function expects a pointer to the BASE of a 
    //format 0 midi file track chunck (format 0 is single track)

    bool isRunningStatus = false;
    uint8_t bytesProcessed = 0;
    uint8_t messageSubType = 0;
    uint32_t currentDeltaTime = 0;
    uint16_t colCount = 0;
    uint8_t * fileBase = midiFileDataPtr;
    uint8_t data0;
    uint8_t data1;
    uint32_t totalColumns = 0;
    sequencerGridItem_t * tempGridItemPtr = NULL;
    uint8_t previousStatusForRunningStatus;
    uint8_t statusByte;


    for(uint16_t a = 0; a < 128; ++a)
    {
        sequencerGridData.gridData[a] = NULL;
        sequencerGridData.gridTailPtrs[a] = NULL;
        sequencerGridData.totalGridColumns = 0;
    }


    freePreviousGridData();

    while(1) //Will need to add a timeout for this
    {

        if (isRunningStatus == false) currentDeltaTime = getMidiDeltaTime(&midiFileDataPtr);
        ESP_LOGI(LOG_TAG, "DeltaTime: %ld", currentDeltaTime);

        if (isRunningStatus) statusByte = previousStatusForRunningStatus; //carry over previous status
        else statusByte = *midiFileDataPtr; //get new status bytes

        vTaskDelay(1);

        if (statusByte == 0xFF) //--- Meta Message Type ---//
        {
            if (isRunningStatus == false) midiFileDataPtr += 1; // now points to base of message data
            else isRunningStatus = false;

            if(processMetaMessage(&midiFileDataPtr)) break;
        }
        else if ((statusByte >= 0x80) && (statusByte <= 0xEF)) //--- Voice Message Type ---//
        {
            // All voice message status bytes have the following format:
            // StatusByte[4-7] = voice message opcode (voice message sub-type)
            // StatusByte[0-3] = channel being addressed (0-15)

            // The MIDI spec features 'running status' capability,
            // if the current event type is the event immediately
            // before it, then the new event does not need a status byte
            messageSubType = (statusByte >> 4);

            previousStatusForRunningStatus = statusByte;

            switch (messageSubType)
            {

                case 0x08: //---Note Off---//
                    // Format (n = channel number)
                    // byte[0] = 0x8n <-- currently pointing at (if NOT running status)
                    // Byte[1] = Note Number <-- pointing here if this is 'running status'
                    // Byte[2] = Velocity

                    ESP_LOGI(LOG_TAG, "note_off channel=%0x, note=%d, velocity=%d, time=%ld",
                            (0x0F & statusByte), *midiFileDataPtr, *(midiFileDataPtr + 1), currentDeltaTime);
                    bytesProcessed = 3;
                    break;


                case 0x09: //---Note On---//
                    // Format (n = channel number)
                    // byte[0] = 0x9n <-- currently pointing at (if NOT running status)
                    // Byte[1] = Note Number <-- pointing here if this is 'running status'
                    // Byte[2] = Velocity

                    //very rough - initial dev
                    if(isRunningStatus)
                    {
                        data0 = *midiFileDataPtr;
                        data1 = *(midiFileDataPtr+1);
                    }
                    else
                    {
                        data0 = *(midiFileDataPtr + 1);
                        data1 = *(midiFileDataPtr + 2);
                    } 

                    if(data0 < 128) //Dont risk segmentation fault
                    {
                        //ESP_LOGI(LOG_TAG, "data0: %d", data0);

                        //note seems legit so create a grid entry for it
                        //appendNewGridItemToRow(data0);
                        
                        //The gridTailPtr in the sequencerGridData struct 
                        //now points to the newly appended row item

                        if(data1 == 0) //Note on with velocity 0 is effectively a NOTE OFF event
                        {
                            //modify the new grid item to become a note-off event
                            sequencerGridData.gridTailPtrs[data0]->statusByte = (0x80 | (0x0F & statusByte));
                            sequencerGridData.gridTailPtrs[data0]->rgbColourCode = rgb_red;
                        }
                        else
                        {
                            //this is a legit note-on event as velocity > 0
                            sequencerGridData.gridTailPtrs[data0]->statusByte = statusByte;
                            sequencerGridData.gridTailPtrs[data0]->rgbColourCode = rgb_green;
                        }

                        sequencerGridData.gridTailPtrs[data0]->dataBytes[0] = data0;
                        sequencerGridData.gridTailPtrs[data0]->dataBytes[1] = data1;
                        sequencerGridData.gridTailPtrs[data0]->deltaTime = currentDeltaTime;

                        if(sequencerGridData.gridTailPtrs[data0]->prevPtr != NULL)
                        {
                            sequencerGridData.gridTailPtrs[data0]->column = sequencerGridData.gridTailPtrs[data0]->prevPtr->column + (currentDeltaTime / PPQN);
                        }
                        else
                        {
                            sequencerGridData.gridTailPtrs[data0]->column = colCount + (currentDeltaTime / PPQN);
                        }                       

                        if(sequencerGridData.gridTailPtrs[data0]->column > colCount) colCount = sequencerGridData.gridTailPtrs[data0]->column;

                        ESP_LOGI(LOG_TAG, "column: %d", sequencerGridData.gridTailPtrs[data0]->column);

                    }

                    if(isRunningStatus)
                    {
                        ESP_LOGI(LOG_TAG, "note_on channel=%0x, note=%d, velocity=%d, time=%ld",
                                (0x0F & statusByte), *midiFileDataPtr, *(midiFileDataPtr + 1), currentDeltaTime);
                    }
                    else{
                        ESP_LOGI(LOG_TAG, "note_on channel=%0x, note=%d, velocity=%d, time=%ld",
                                (0x0F & statusByte), *(midiFileDataPtr+1), *(midiFileDataPtr + 2), currentDeltaTime);                        
                    }

                    bytesProcessed = 3;
                    break;


                case 0x0A: //---Aftertouch---//
                    // Format (n = channel number)
                    // Byte[0] = 0xAn <-- currently pointing at (if NOT running status)
                    // Byte[1] = Note Number <-- pointing here if this is 'running status'
                    // Byte[2] = Pressure Value
                    ESP_LOGI(LOG_TAG, "aftertouch channel=%0x, note=%d, pressure=%d, time=%ld",
                            (0x0F & statusByte), *midiFileDataPtr, *(midiFileDataPtr + 1), currentDeltaTime);
                    bytesProcessed = 3;
                    break;

                case 0x0B: //---Control Change---//
                    // Format (n = channel number)
                    // Byte[0] =  0xBn <-- currently pointing at (if NOT running status)
                    // Byte[1] = Control opcode <-- pointing here if this is 'running status'
                    // Byte[2] = Value
                    ESP_LOGI(LOG_TAG, "control_change channel=%0x, control=%d, value=%d, time=%ld",
                            (0x0F & statusByte), *midiFileDataPtr, *(midiFileDataPtr + 1), currentDeltaTime);
                    bytesProcessed = 3;
                    break;

                case 0x0C: //---Program Change---//
                    // Format (n = channel num)
                    // Byte[0] = 0xCn <-- currently pointing at (if NOT running status)
                    // Byte[1] = Program value (selects instrument) <-- pointing here if this is 'running status'
                    ESP_LOGI(LOG_TAG, "program_change channel=%0x, program=%d, time=%ld",
                            (0x0F & statusByte), *midiFileDataPtr, currentDeltaTime);
                    bytesProcessed = 2;
                    break;

                case 0x0D: //---Channel Pressure---//
                    // Format (n = channel num)
                    // Byte[0] = 0xDn <-- currently pointing at (if NOT running status)
                    // Byte[1] = Pressure value <-- pointing here if this is 'running status'
                    ESP_LOGI(LOG_TAG, "channel_pressure channel=%0x, value=%d, time=%ld",
                            (0x0F & statusByte), *midiFileDataPtr, currentDeltaTime);
                    bytesProcessed = 2;
                    break;

                case 0x0E: //---Pitch Wheel---//
                    // Format (n = channel num)
                    // Byte[0] = 0xEn <-- currently pointing at (if NOT running status)
                    // Byte[1] = Pitch Value MSB (these two bytes must each have bit 8 removed, concatenate result) <-- pointing here if this is 'running status'
                    // Byte[2] = Pitch Value LSB
                    ESP_LOGI(LOG_TAG, "pitch_wheel channel=%0x, msb=%d, lsb=%d, time=%ld",
                            (0x0F & statusByte), *midiFileDataPtr, *(midiFileDataPtr + 1), currentDeltaTime);
                    bytesProcessed = 3;
                    break;

                default: //--- ERROR ---//
                    ESP_LOGE(LOG_TAG, "VOICE MESSAGE: ERROR Unrecognised Message!");
                    // HANDLE ERROR!
                    break;
            }


            if(isRunningStatus == true)
            {
                isRunningStatus = false;
                --bytesProcessed; // no status byte to send
            }

            midiFileDataPtr += bytesProcessed;

            ESP_LOGI(LOG_TAG, "Event processed");
            ESP_LOGI(LOG_TAG, "\n");
        }
        else
        {
            // In order to reach here the playback pointer has
            // reached a status byte that it doesn't recognise.
            // This must be a 'running status', where subsequent
            // events of the same type may ommit the status byte
            ESP_LOGI(LOG_TAG, "Running status detected");
            isRunningStatus = true; // Must be running status?
        }

        vTaskDelay(1);
    }

    /*
    //FOR DEBUGGING
    for(uint8_t a = 0; a < TOTAL_MIDI_NOTES; ++a)
    {   
        if(sequencerGridData.gridData[a] != NULL)
        {
            ESP_LOGI(LOG_TAG, "DATA FOR ROW %d", a);
            tempGridItemPtr = sequencerGridData.gridData[a];
            while(tempGridItemPtr != NULL)
            {
                vTaskDelay(500);
                ESP_LOGI(LOG_TAG, "column: %d", tempGridItemPtr->column);
                ESP_LOGI(LOG_TAG, "deltaTime: %ld", tempGridItemPtr->deltaTime);
                ESP_LOGI(LOG_TAG, "Event type: %0x", tempGridItemPtr->statusByte);
                ESP_LOGI(LOG_TAG, "Note num: %0x", tempGridItemPtr->dataBytes[0]);
                ESP_LOGI(LOG_TAG, "Velocity: %0x", tempGridItemPtr->dataBytes[1]);
                tempGridItemPtr = tempGridItemPtr->nextPtr;
            }
            ESP_LOGI(LOG_TAG, "\n");
        }
    }
    

    for(uint8_t a = 0; a < 100; ++a)
    {   
        ESP_LOGI(LOG_TAG, "data[%d] = %0x", a, fileBase[a]);
    }
    */

    sequencerGridData.totalGridColumns = colCount;
    ESP_LOGI(LOG_TAG, "****************** Column count: %d ************", colCount);
    ESP_LOGI(LOG_TAG, "DONE!");

    return 0;
}


void updateGridLEDs(uint8_t rowOffset, uint16_t columnOffset)
{
    //add checks for limits accoridng to project
    sequencerGridItem_t * tempGridItemPtr = NULL;
    sequencerGridItem_t * searchItemPtr = NULL;
    uint8_t idx = 0;
    uint8_t relativeColumn = 0;
    uint8_t rowNumber = 0;
    uint8_t numGridSteps = 0;
    uint32_t totalNoteDuration = 0;
    rgbLedColour_t gridRGBCodes[48] = {0}; //physical grid size on device - add definition

    for(uint8_t a = rowOffset; a < (rowOffset + 7); ++a) 
    { 
        //Check if row has any items at all allocated
        if(sequencerGridData.gridData[a] != NULL)
        {

            //Check whether starting column is beyond the final item in this row
            //if it is we can just skip processing the row, speeding things up
            if(sequencerGridData.gridTailPtrs[a]->column >= columnOffset) //optimization possible for equal condition
            {
                ESP_LOGI(LOG_TAG, "Found some data on row %d", a);
                //Now we need to find any items that may exist in the grid area 
                tempGridItemPtr = sequencerGridData.gridData[a];

                findEventsWithinWindow:
                if((tempGridItemPtr->column >= columnOffset) && (tempGridItemPtr->column < columnOffset + 8))
                {
                    ESP_LOGI(LOG_TAG, "Hit within target grid window");
                }
                else
                {
                    if(tempGridItemPtr->nextPtr !=  NULL)
                    {
                        ESP_LOGI(LOG_TAG, "Traversing list");
                        tempGridItemPtr = tempGridItemPtr->nextPtr;
                        goto findEventsWithinWindow;
                    }
                    else
                    {
                        goto abortCurrentRow;
                    }
                }

                ESP_LOGI(LOG_TAG, "HERE");

                //--------------------------------------------------------------------------
                //If everything worked 'tempGridItemPtr' should now be pointing to the first
                //item for the specified row that falls within the target grid area. There
                //be a single item or multiple items that fall within the target grid area
                //--------------------------------------------------------------------------

                loopUntilAllColumnsProcessed:
                
                relativeColumn = tempGridItemPtr->column - columnOffset;
                if((tempGridItemPtr->statusByte & 0xF0) != 0x80)
                {
                    gridRGBCodes[relativeColumn + (rowNumber * 8)] = tempGridItemPtr->rgbColourCode;
                }


                if(relativeColumn < 7) //If we're NOT dealing with last column 
                {
                    if((tempGridItemPtr->statusByte & 0xF0) == 0x90) //Note On
                    {
                        //When we have a note whose duration spans multiple steps,
                        //all steps that make up that duration should also be illuminated
                        
                        //we're currenly dealing with a note on message,
                        //we need to find the corresponding note off event
                        //which SHOULD appear further down the list for the 
                        //current row. We need to find that note-off event 
                        //and compute the total duration of the note. 
                        if(tempGridItemPtr->nextPtr != NULL)
                        {
                            //Peek at next event for this row, see if its note-off
                            if((tempGridItemPtr->nextPtr->statusByte & 0xF0) == 0x80)
                            {
                                numGridSteps = tempGridItemPtr->nextPtr->deltaTime / PPQN;
                                if(numGridSteps)
                                {
                                    --numGridSteps; //The note off itself shouldn't be counted
                                    for(uint8_t a = 1; a <= numGridSteps; ++a)
                                    {
                                        //illulimate steps in order to show note duration
                                        gridRGBCodes[relativeColumn + (rowNumber * 8) + a] = tempGridItemPtr->rgbColourCode;
                                    }
                                }
                            }
                            else//There next item wasn't a note-off
                            {   //we now need to iterate through the list
                                //for current row until the note-off
                                searchForNoteOff:
                                searchItemPtr = tempGridItemPtr->nextPtr;
                                totalNoteDuration += searchItemPtr->deltaTime;
                                while(searchItemPtr->nextPtr != NULL)
                                {
                                    searchItemPtr = searchItemPtr->nextPtr;
                                    if((searchItemPtr->statusByte & 0xF0) == 0x80)
                                    {
                                        numGridSteps = totalNoteDuration / PPQN;

                                        //Check to make sure we dont write further than column
                                        while((relativeColumn + numGridSteps) > 7) --numGridSteps;

                                        if(numGridSteps)
                                        {
                                            --numGridSteps; //The note off itself shouldn't be counted
                                            for(uint8_t a = 1; a <= numGridSteps; ++a)
                                            {
                                                //illulimate steps in order to show note duration
                                                gridRGBCodes[relativeColumn + (rowNumber * 8) + a] = tempGridItemPtr->rgbColourCode;
                                            }
                                        }                                        
                                    }
                                    else goto searchForNoteOff;
                                }
                            }
                        }
                    }
                }

                if(relativeColumn < 7)
                {
                    if(tempGridItemPtr->nextPtr !=  NULL) 
                    {
                        tempGridItemPtr = tempGridItemPtr->nextPtr;
                        if(tempGridItemPtr->column <= (columnOffset + 7)) goto loopUntilAllColumnsProcessed;
                    }
                }
            }
            abortCurrentRow:
        }
        ++rowNumber;
    }

    writeEntireGridFromArray(gridRGBCodes);
}


static uint8_t processMetaMessage(uint8_t **midiFilePtr)
{
    // This function deals with midi meta event messages.
    // A meta message is NEVER sent over midi, it is information
    // about the file being played, intended for the playback device.

    // Meta messages ONLY exist in midi FILES, they are NEVER sent or revieved over midi.

    uint8_t numBytes;

    switch (**midiFilePtr)
    {
        case metaEvent_deviceName:
            ESP_LOGI(LOG_TAG, "Device Name meta event detected, ignoring");
            *midiFilePtr += 1;            // Will be pointing at data length after this
            numBytes = **midiFilePtr;     // Get number of data bytes assosiated with thing meta event
            *midiFilePtr += numBytes + 1; // Now pointing to delta-time of next event
            break;

        case metaEvent_midiPort:
            *midiFilePtr += 1;            // Will be pointing at data length after this
            numBytes = **midiFilePtr;     // Get number of data bytes assosiated with thing meta event
            *midiFilePtr += numBytes + 1; // Now pointing to delta-time of next event
            ESP_LOGI(LOG_TAG, "Midi Port meta event detected, ignoring");
            break;

        case metaEvent_sequenceNum:
            // Two bytes
            *midiFilePtr += 3;
            ESP_LOGI(LOG_TAG, "Sequence Number meta event detected, ignoring");
            break;

        case metaEvent_cuePoint:
        case metaEvent_marker:
        case metaEvent_lyrics:
        case metaEvent_instrumentName:
        case metaEvent_trackName:
        case metaEvent_copyright:
        case metaEvent_textField:
            ESP_LOGI(LOG_TAG, "HERE!");
            // All mevta events of variable length
            // Not bothered about any of these so just increment
            // file pointer onto the delta-time base of the next event
            *midiFilePtr += 1;            // Will be pointing at data length after this
            numBytes = **midiFilePtr;     // Get number of data bytes assosiated with thing meta event
            *midiFilePtr += numBytes + 1; // Now pointing to delta-time of next event
            ESP_LOGI(LOG_TAG, "Ignored variable-length meta message");
            break;

        case metaEvent_channelPrefix:
            // Single byte
            *midiFilePtr += 1;            // Will be pointing at data length after this
            numBytes = **midiFilePtr;     // Get number of data bytes assosiated with thing meta event
            *midiFilePtr += numBytes + 1; // Now pointing to delta-time of next event
            ESP_LOGI(LOG_TAG, "Channel prefix meta event detected, ignoring");
            break;

        case metaEvent_endOfTrack:
            // Single byte
            ESP_LOGI(LOG_TAG, "End of midi track detected!");
            return 1;
            break;

        case metaEvent_setTempo:
            // Three bytes
            //ESP_LOGI(LOG_TAG, "Set tempo to %ld microseconds per quater-note", getMicroSecondsPerQuaterNote(*midiFilePtr));
            *midiFilePtr += 1;            // Will be pointing at data length after this
            numBytes = **midiFilePtr;     // Get number of data bytes assosiated with thing meta event
            *midiFilePtr += numBytes + 1; // Now pointing to delta-time of next event
            break;

        case metaEvent_smpteOffset:
            // Five bytes
            *midiFilePtr += 1;            // Will be pointing at data length after this
            numBytes = **midiFilePtr;     // Get number of data bytes assosiated with thing meta event
            *midiFilePtr += numBytes + 1; // Now pointing to delta-time of next event
            ESP_LOGI(LOG_TAG, "SmpteOffset meta event detected, ignoring");
            break;

        case metaEvent_setTimeSig:
            // Four bytes
            *midiFilePtr += 1;            // Will be pointing at data length after this
            numBytes = **midiFilePtr;     // Get number of data bytes assosiated with thing meta event
            *midiFilePtr += numBytes + 1; // Now pointing to delta-time of next event
            ESP_LOGI(LOG_TAG, "Time signature meta event detected, ignoring");
            break;

        case metaEvent_keySignature:
            // Two bytes
            *midiFilePtr += 1;            // Will be pointing at data length after this
            numBytes = **midiFilePtr;     // Get number of data bytes assosiated with thing meta event
            *midiFilePtr += numBytes + 1; // Now pointing to delta-time of next event
            ESP_LOGI(LOG_TAG, "Key signature meta event detected, ignoring");
            break;

        case metaEvent_sequencerSpecific:
            // for device specific use
            ESP_LOGE(LOG_TAG, "Device specific meta event detected");
            break;

        default:
            ESP_LOGE(LOG_TAG, "Unrecognised meta event opcode");
            *midiFilePtr += 1; //try increment
            break;
    }

    return 0;
}

static uint8_t appendNewGridItemToRow(uint8_t midiNoteNumber)
{
    if(midiNoteNumber > 127) return 1;

    sequencerGridItem_t * tempPtr = NULL;

    if(sequencerGridData.gridData[midiNoteNumber] == NULL)
    {
        ESP_LOGI(LOG_TAG, "First grid item on row - note num %d", midiNoteNumber);
        sequencerGridData.gridData[midiNoteNumber] = createNewGridItem(NULL);
        sequencerGridData.gridTailPtrs[midiNoteNumber] = sequencerGridData.gridData[midiNoteNumber];
        sequencerGridData.gridTailPtrs[midiNoteNumber]->prevPtr = NULL; //First item in list, so no prevPtr
        sequencerGridData.gridTailPtrs[midiNoteNumber]->nextPtr = NULL; //Currently no other items in linked list
    }
    else
    {
        //Get the current tail pointer before we append a new item
        //to the list. The pointer set in 'tempPtr' will be used
        //to set the 'prevPtr' value for the newly appended item
        tempPtr = sequencerGridData.gridTailPtrs[midiNoteNumber];

        ESP_LOGI(LOG_TAG, "Appending new grid item - note num %d", midiNoteNumber);
        if(sequencerGridData.gridTailPtrs[midiNoteNumber]->nextPtr != NULL)
        {
            ESP_LOGE(LOG_TAG, "System fault in 'appendNewGridItemToRow");
            return 1;
        }
        sequencerGridData.gridTailPtrs[midiNoteNumber]->nextPtr = createNewGridItem(NULL);
        sequencerGridData.gridTailPtrs[midiNoteNumber] = sequencerGridData.gridTailPtrs[midiNoteNumber]->nextPtr;
        sequencerGridData.gridTailPtrs[midiNoteNumber]->prevPtr = tempPtr;
        sequencerGridData.gridTailPtrs[midiNoteNumber]->nextPtr = NULL; //This is the end of list
    }

    return 0; 
}


inline static sequencerGridItem_t * createNewGridItem(const sequencerGridItem_t * const prevPtr)
{
    //Might change this later to use pre-allocated mempool
    sequencerGridItem_t * gridData = heap_caps_malloc(sizeof(sequencerGridItem_t), MALLOC_CAP_SPIRAM);

    memset(gridData, 0, sizeof(sequencerGridItem_t));

    gridData->prevPtr = prevPtr;
    gridData->nextPtr = NULL;

    return gridData;
}


static uint32_t getMidiDeltaTime(uint8_t **deltaTimeBase)
{
    // This function processes the delta-time bytes of a midi event
    // it exptects a pointer to the base of a delta-time.

    // Delta times are ALWAYS four bytes max, MSB FIRST.
    // Bit 8 of a delta-time byte is a flag - indicating more bytes to follow.
    // The final delta-time value is created by removing the flag bit from each
    // byte and concatenating the result.

    uint32_t tempStore = 0;
    uint32_t result = 0;
    uint8_t numBytes = 0;

loopDeltaTime: //--- TIGHT LOOP ---//

    ESP_LOGI(LOG_TAG, "*Ptr: %d", **deltaTimeBase);

    // Always have at least one byte
    tempStore |= **deltaTimeBase;

    if (HAS_MORE_DELTA_TIME_BYTES(**deltaTimeBase)) // IF BIT 8 SET THEN TRUE
    {
        if (numBytes < 3) // A midi delta-time has 4 bytes MAX
        {
            tempStore <<= 8;
            ++numBytes;
            *deltaTimeBase += 1;
            goto loopDeltaTime; //--- TIGHT LOOP ---//
        }
    }

    for (uint8_t a = 0; a <= numBytes; ++a)
    {
        // For each delta-time byte we need to
        // remove bit 8 and concatenate the result
        result |= ((tempStore & (0x0000007F << (a * 8))) >> ((a ? 1 : 0) * a));
    }

    *deltaTimeBase += 1; // Set to point at delta time of next midi event


    return result;
}


static uint16_t deltaTimeToColumnOffset(uint32_t deltaTime)
{
   return (deltaTime / TEMPO_IN_MICRO);
}


static void freePreviousGridData(void)
{
    uint16_t numNodes;
    sequencerGridItem_t * nodePtr;
    sequencerGridItem_t * prevNode;

    for(uint8_t a = 0; a < TOTAL_MIDI_NOTES; ++a)
    {   
        numNodes = 0; //reset before processing next row of grid

        if(sequencerGridData.gridData[a] != 0) //If this row has anything allocated
        {
            ESP_LOGI(LOG_TAG, "Freeing grid data for previous file");

            numNodes++;
            nodePtr = sequencerGridData.gridData[a]->nextPtr;

            while(nodePtr != NULL)
            {
                numNodes++;
                nodePtr = sequencerGridData.gridData[a]->nextPtr;
            }

            //Reached the end of the linked list for current row
            //Now free up each node in list working back from tail end

            for(int32_t b = (numNodes - 1); b >= 0; --b)
            {
                prevNode = nodePtr->prevPtr;
                free(nodePtr);
                if(prevNode == NULL) break; //all nodes freed for current row
                else nodePtr = prevNode;
            }
        }
    }
}




uint8_t appendNewNoteToGridRow(uint16_t column_num, uint8_t statusByte, uint8_t midiNoteNumber, uint8_t midiVelocity, uint8_t durationInSteps, bool autoAddNoteOff)
{
    if(midiNoteNumber > 127) return 1;

    uint32_t deltaTime;

    ESP_LOGI(LOG_TAG, "Midi note numer %0x", midiNoteNumber);

    sequencerGridItem_t * tempPtr = NULL;

    if(column_num > sequencerGridData.totalGridColumns) sequencerGridData.totalGridColumns = column_num;

    if(sequencerGridData.gridData[midiNoteNumber] == NULL)
    {
        sequencerGridData.gridData[midiNoteNumber] = createNewGridItem(NULL);
        sequencerGridData.gridData[midiNoteNumber]->column = column_num;
        sequencerGridData.gridData[midiNoteNumber]->statusByte = statusByte;
        sequencerGridData.gridData[midiNoteNumber]->dataBytes[0] = midiNoteNumber;
        sequencerGridData.gridData[midiNoteNumber]->dataBytes[1] = midiVelocity;
        sequencerGridData.gridData[midiNoteNumber]->deltaTime = column_num * ((sequencer_ppqn*4) / sequencer_quantization);
        ESP_LOGI(LOG_TAG, "Added new grid item (first in row) with delta time of %ld", sequencerGridData.gridData[midiNoteNumber]->deltaTime);
        if(statusByte == 0x90) sequencerGridData.gridData[midiNoteNumber]->rgbColourCode = rgb_green;
        if(statusByte == 0x80) sequencerGridData.gridData[midiNoteNumber]->rgbColourCode = rgb_off;

        sequencerGridData.gridTailPtrs[midiNoteNumber] = sequencerGridData.gridData[midiNoteNumber];
        sequencerGridData.gridTailPtrs[midiNoteNumber]->prevPtr = NULL; //First item in list, so no prevPtr
        sequencerGridData.gridTailPtrs[midiNoteNumber]->nextPtr = NULL; //Currently no other items in linked list
    }
    else
    {
        //Get the current tail pointer before we append a new item
        //to the list. The pointer set in 'tempPtr' will be used
        //to set the 'prevPtr' value for the newly appended item
        tempPtr = sequencerGridData.gridTailPtrs[midiNoteNumber];

        if(sequencerGridData.gridTailPtrs[midiNoteNumber]->nextPtr != NULL)
        {
            ESP_LOGE(LOG_TAG, "System fault in 'appendNewGridItemToRow");
            return 1;
        }
        sequencerGridData.gridTailPtrs[midiNoteNumber]->nextPtr = createNewGridItem(NULL);
        sequencerGridData.gridTailPtrs[midiNoteNumber] = sequencerGridData.gridTailPtrs[midiNoteNumber]->nextPtr;

        sequencerGridData.gridTailPtrs[midiNoteNumber]->column = column_num;
        sequencerGridData.gridTailPtrs[midiNoteNumber]->statusByte = statusByte;
        sequencerGridData.gridTailPtrs[midiNoteNumber]->dataBytes[0] = midiNoteNumber;
        sequencerGridData.gridTailPtrs[midiNoteNumber]->dataBytes[1] = midiVelocity;
        sequencerGridData.gridTailPtrs[midiNoteNumber]->deltaTime = column_num * ((sequencer_ppqn*4) / sequencer_quantization);
        sequencerGridData.gridTailPtrs[midiNoteNumber]->deltaTime -= tempPtr->deltaTime;
        if(statusByte == 0x90) sequencerGridData.gridTailPtrs[midiNoteNumber]->rgbColourCode = rgb_green;
        if(statusByte == 0x80) sequencerGridData.gridTailPtrs[midiNoteNumber]->rgbColourCode = rgb_off;

        ESP_LOGI(LOG_TAG, "Added new grid item with delta time of %ld", sequencerGridData.gridTailPtrs[midiNoteNumber]->deltaTime);

        sequencerGridData.gridTailPtrs[midiNoteNumber]->prevPtr = tempPtr;
        sequencerGridData.gridTailPtrs[midiNoteNumber]->nextPtr = NULL; //This is the end of list
    }

    if(autoAddNoteOff)
    {
        //Now we can add a corresponding note off event
        tempPtr = sequencerGridData.gridTailPtrs[midiNoteNumber];

        if(sequencerGridData.gridTailPtrs[midiNoteNumber]->nextPtr != NULL)
        {
            ESP_LOGE(LOG_TAG, "System fault in 'appendNewGridItemToRow");
            return 1;
        }
        sequencerGridData.gridTailPtrs[midiNoteNumber]->nextPtr = createNewGridItem(NULL);
        sequencerGridData.gridTailPtrs[midiNoteNumber] = sequencerGridData.gridTailPtrs[midiNoteNumber]->nextPtr;

        sequencerGridData.gridTailPtrs[midiNoteNumber]->column = column_num + durationInSteps;
        sequencerGridData.gridTailPtrs[midiNoteNumber]->statusByte = 0x80;
        sequencerGridData.gridTailPtrs[midiNoteNumber]->dataBytes[0] = midiNoteNumber;
        sequencerGridData.gridTailPtrs[midiNoteNumber]->dataBytes[1] = 0;
        sequencerGridData.gridTailPtrs[midiNoteNumber]->deltaTime = ((sequencer_ppqn*4) / sequencer_quantization);
        sequencerGridData.gridTailPtrs[midiNoteNumber]->rgbColourCode = rgb_off;

        ESP_LOGI(LOG_TAG, "Added new grid item with delta time of %ld", sequencerGridData.gridTailPtrs[midiNoteNumber]->deltaTime);

        sequencerGridData.gridTailPtrs[midiNoteNumber]->prevPtr = tempPtr;
        sequencerGridData.gridTailPtrs[midiNoteNumber]->nextPtr = NULL; //This is the end of list
    }

    return 0; 
}




uint8_t appendNewNoteToGridRow(uint16_t column_num, uint8_t statusByte, uint8_t midiNoteNumber, uint8_t midiVelocity, uint8_t durationInSteps, bool autoAddNoteOff)
{
    if(midiNoteNumber > 127) return 1;

    uint32_t deltaTime;
    bool intermediaryNode = false;

    ESP_LOGI(LOG_TAG, "Midi note numer %0x", midiNoteNumber);

    sequencerGridItem_t * tempPtr = NULL;
    sequencerGridItem_t * tempNextPtr = NULL;
    sequencerGridItem_t * tempPrevPtr = NULL;
    uint16_t columnIdx = 0;
    uint8_t columnBitMask = 0;

    uint16_t prevTotalColumns = sequencerGridData.totalGridColumns;
    if(column_num > sequencerGridData.totalGridColumns) sequencerGridData.totalGridColumns = column_num;


    if(column_num > 0) columnIdx = column_num / 8;

    columnBitMask = column_num - (columnIdx * 8);

    currentActiveColumnRecord[columnIdx] |= 1 << columnBitMask; 


    if(sequencerGridData.gridData[midiNoteNumber] == NULL)
    {
        ESP_LOGI(LOG_TAG, "status byte: %0x", statusByte);
        sequencerGridData.gridData[midiNoteNumber] = createNewGridItem(NULL);
        sequencerGridData.gridData[midiNoteNumber]->column = column_num;
        sequencerGridData.gridData[midiNoteNumber]->statusByte = statusByte;
        sequencerGridData.gridData[midiNoteNumber]->dataBytes[0] = midiNoteNumber;
        sequencerGridData.gridData[midiNoteNumber]->dataBytes[1] = midiVelocity;
        sequencerGridData.gridData[midiNoteNumber]->deltaTime = column_num * ((sequencer_ppqn*4) / sequencer_quantization);
        ESP_LOGI(LOG_TAG, "Added new grid item (first in row) with delta time of %ld", sequencerGridData.gridData[midiNoteNumber]->deltaTime);
        if(statusByte == 0x90) sequencerGridData.gridData[midiNoteNumber]->rgbColourCode = rgb_green;
        if(statusByte == 0x80) sequencerGridData.gridData[midiNoteNumber]->rgbColourCode = rgb_off;

        sequencerGridData.gridTailPtrs[midiNoteNumber] = sequencerGridData.gridData[midiNoteNumber];
        sequencerGridData.gridTailPtrs[midiNoteNumber]->prevPtr = NULL; //First item in list, so no prevPtr
        sequencerGridData.gridTailPtrs[midiNoteNumber]->nextPtr = NULL; //Currently no other items in linked list
    }
    else
    {
        if(column_num < sequencerGridData.gridTailPtrs[midiNoteNumber]->column)
        {
            //Events in the grid data linked lists need to
            //occur in the same order as they are executed
            
            //This newly inputed grid entry occurs BEFORE the 
            //current last item in the list, we therefore need
            //to find the correct location in the linked list

            //If this is not accounted for the midi 
            //file will have incorrect note orderings 
            intermediaryNode = true;

            ESP_LOGI(LOG_TAG, "Attemping to find inserting point for node");

            tempPtr = sequencerGridData.gridTailPtrs[midiNoteNumber]->prevPtr;
            while(tempPtr != NULL)
            {
                if(tempPtr->column <= column_num) break;
                tempPrevPtr = tempPrevPtr;
                tempPtr = tempPtr->prevPtr;
            }


            ESP_LOGI(LOG_TAG, "Got the insertion point for the node");


            if(tempPtr ==  NULL)
            {

                tempPtr = sequencerGridData.gridData[midiNoteNumber];
                tempNextPtr = sequencerGridData.gridData[midiNoteNumber];
                tempPrevPtr = NULL;

                sequencerGridData.gridData[midiNoteNumber] = createNewGridItem(NULL);

                sequencerGridData.gridData[midiNoteNumber]->column = column_num;
                sequencerGridData.gridData[midiNoteNumber]->statusByte = statusByte;
                sequencerGridData.gridData[midiNoteNumber]->dataBytes[0] = midiNoteNumber;
                sequencerGridData.gridData[midiNoteNumber]->dataBytes[1] = midiVelocity;
                sequencerGridData.gridData[midiNoteNumber]->deltaTime = column_num * ((sequencer_ppqn*4) / sequencer_quantization);

                //We have inserted a new node at the requested column
                
                uint16_t mostRecentActiveColumn;
                while(1)
                {
                    
                    if(currentActiveColumnRecord[columnIdx] | (1 << columnBitMask))
                    {
                        mostRecentActiveColumn = columnBitMask + (columnIdx * 8);
                        //ESP_LOGI(LOG_TAG, "Most recent column = %d", mostRecentActiveColumn);
                        break;
                    }

                    if(columnBitMask > 0 ) --columnBitMask;

                    if(columnBitMask == 0)
                    {
                        if(columnIdx > 0)
                        {
                            --columnIdx;
                            columnBitMask = 7;
                        } 
                        else
                        {
                            ESP_LOGE(LOG_TAG, "Error: grid data fault");
                            break;
                        }
                    }

                } 

                tempPtr->deltaTime -= sequencerGridData.gridData[midiNoteNumber]->deltaTime;

                if(midiNoteNumber == 0x36) ESP_LOGI(LOG_TAG, "************* COLUMN: %d  DELTA-TIME: %ld  PREV-EVENT-COLUMN %d", 
                    column_num, sequencerGridData.gridTailPtrs[midiNoteNumber]->deltaTime, tempPtr->column);

                if(statusByte == 0x90) sequencerGridData.gridData[midiNoteNumber]->rgbColourCode = rgb_green;
                if(statusByte == 0x80) sequencerGridData.gridData[midiNoteNumber]->rgbColourCode = rgb_off;

                sequencerGridData.gridData[midiNoteNumber]->nextPtr = tempNextPtr;
                sequencerGridData.gridData[midiNoteNumber]->prevPtr = tempPrevPtr;
                tempPtr->prevPtr = sequencerGridData.gridData[midiNoteNumber];

                tempPtr = sequencerGridData.gridData[midiNoteNumber];

            } 
            else
            {
                //Storing pointers in prep for 
                //inserting intermediary node into list
                tempNextPtr = tempPtr->nextPtr;
                tempPrevPtr = tempPtr;

                tempPtr->nextPtr = createNewGridItem(NULL);
                tempPtr = tempPtr->nextPtr;
                ESP_LOGI(LOG_TAG, "status byte: %0x", statusByte);
                tempPtr->column = column_num;
                tempPtr->statusByte = statusByte;
                tempPtr->dataBytes[0] = midiNoteNumber;
                tempPtr->dataBytes[1] = midiVelocity;
                tempPtr->deltaTime = column_num * ((sequencer_ppqn*4) / sequencer_quantization);

                tempPrevPtr->deltaTime -= tempPtr->deltaTime;

                if(statusByte == 0x90) tempPtr->rgbColourCode = rgb_green;
                if(statusByte == 0x80) tempPtr->rgbColourCode = rgb_off;

                tempPtr->nextPtr = tempNextPtr;
                tempPtr->prevPtr = tempPrevPtr;
                tempPrevPtr->nextPtr = tempPtr;

                tempPtr->deltaTime -= tempPtr->prevPtr->deltaTime;
            }


            ESP_LOGI(LOG_TAG, "Added itermediary node to list");


            if(autoAddNoteOff)
            {
                ESP_LOGI(LOG_TAG, "Processing auto note-off");

                tempNextPtr = tempPtr->nextPtr;
                tempPrevPtr = tempPtr;

                tempPtr->nextPtr = createNewGridItem(NULL);
                tempPtr = tempPtr->nextPtr;
                tempPtr->column = column_num + durationInSteps;
                tempPtr->statusByte = 0x80;
                tempPtr->dataBytes[0] = midiNoteNumber;
                tempPtr->dataBytes[1] = 0;
                tempPtr->deltaTime = ((sequencer_ppqn*4) / sequencer_quantization) * durationInSteps;

                if(statusByte == 0x90) tempPtr->rgbColourCode = rgb_green;
                if(statusByte == 0x80) tempPtr->rgbColourCode = rgb_off;

                tempPtr->nextPtr = tempNextPtr;
                tempPtr->prevPtr = tempPrevPtr;
                tempPrevPtr->nextPtr = tempPtr;
            }

            goto end;
        }

        //Get the current tail pointer before we append a new item
        //to the list. The pointer set in 'tempPtr' will be used
        //to set the 'prevPtr' value for the newly appended item
        tempPtr = sequencerGridData.gridTailPtrs[midiNoteNumber];

        if(sequencerGridData.gridTailPtrs[midiNoteNumber]->nextPtr != NULL)
        {
            ESP_LOGE(LOG_TAG, "System fault in 'appendNewGridItemToRow");
            return 1;
        }
        sequencerGridData.gridTailPtrs[midiNoteNumber]->nextPtr = createNewGridItem(NULL);
        sequencerGridData.gridTailPtrs[midiNoteNumber] = sequencerGridData.gridTailPtrs[midiNoteNumber]->nextPtr;
        ESP_LOGI(LOG_TAG, "status byte: %0x", statusByte);
        sequencerGridData.gridTailPtrs[midiNoteNumber]->column = column_num;
        sequencerGridData.gridTailPtrs[midiNoteNumber]->statusByte = statusByte;
        sequencerGridData.gridTailPtrs[midiNoteNumber]->dataBytes[0] = midiNoteNumber;
        sequencerGridData.gridTailPtrs[midiNoteNumber]->dataBytes[1] = midiVelocity;
        sequencerGridData.gridTailPtrs[midiNoteNumber]->deltaTime = (column_num - tempPtr->column) * ((sequencer_ppqn*4) / sequencer_quantization);

        if(midiNoteNumber == 0x36) ESP_LOGI(LOG_TAG, "************* COLUMN: %d  DELTA-TIME: %ld  PREV-EVENT-COLUMN %d", 
            column_num, sequencerGridData.gridTailPtrs[midiNoteNumber]->deltaTime, tempPtr->column);

        if(statusByte == 0x90) sequencerGridData.gridTailPtrs[midiNoteNumber]->rgbColourCode = rgb_green;
        if(statusByte == 0x80) sequencerGridData.gridTailPtrs[midiNoteNumber]->rgbColourCode = rgb_off;

        ESP_LOGI(LOG_TAG, "Added new grid item with delta time of %ld", sequencerGridData.gridTailPtrs[midiNoteNumber]->deltaTime);

        sequencerGridData.gridTailPtrs[midiNoteNumber]->prevPtr = tempPtr;
        sequencerGridData.gridTailPtrs[midiNoteNumber]->nextPtr = NULL; //This is the end of list
    }

    if(autoAddNoteOff)
    {
        //Now we can add a corresponding note off event
        tempPtr = sequencerGridData.gridTailPtrs[midiNoteNumber];


        if(sequencerGridData.gridTailPtrs[midiNoteNumber]->nextPtr != NULL)
        {
            ESP_LOGE(LOG_TAG, "System fault in 'appendNewGridItemToRow");
            return 1;
        }
        sequencerGridData.gridTailPtrs[midiNoteNumber]->nextPtr = createNewGridItem(NULL);
        sequencerGridData.gridTailPtrs[midiNoteNumber] = sequencerGridData.gridTailPtrs[midiNoteNumber]->nextPtr;

        sequencerGridData.gridTailPtrs[midiNoteNumber]->column = column_num + durationInSteps;
        sequencerGridData.gridTailPtrs[midiNoteNumber]->statusByte = 0x80;
        sequencerGridData.gridTailPtrs[midiNoteNumber]->dataBytes[0] = midiNoteNumber;
        sequencerGridData.gridTailPtrs[midiNoteNumber]->dataBytes[1] = 0;
        sequencerGridData.gridTailPtrs[midiNoteNumber]->deltaTime = ((sequencer_ppqn*4) / sequencer_quantization) * durationInSteps;
        sequencerGridData.gridTailPtrs[midiNoteNumber]->rgbColourCode = rgb_off;

        ESP_LOGI(LOG_TAG, "Added new grid item with delta time of %ld", sequencerGridData.gridTailPtrs[midiNoteNumber]->deltaTime);

        sequencerGridData.gridTailPtrs[midiNoteNumber]->prevPtr = tempPtr;
        sequencerGridData.gridTailPtrs[midiNoteNumber]->nextPtr = NULL; //This is the end of list
    }


    end:
    return 0; 
}



                    //Format (n = channel number)
                    //byte[0] = 0x8n <-- currently pointing at (if NOT running status)
                    //Byte[1] = Note Number <-- pointing here if this is 'running status'
                    //Byte[2] = Velocity

                    data0 = *(midiFileDataPtr + 1);
                    data1 = *(midiFileDataPtr + 2);

                    if(data0 < 128) //Dont risk segmentation fault
                    {
                        ESP_LOGI(LOG_TAG, "data0 (decimal): %d, (hex): %0x", data0, data0);
                        ESP_LOGI(LOG_TAG, "data1 (decimal): %d, (hex): %0x", data1, data1);

                        //The gridTailPtr in the sequencerGridData struct 
                        //now points to the newly appended row item

                        //--- Construct a double linked list for each row of sequencer used
                        //--- each linked list node is a struct containing pointers and midi data
                        if(sequencerGridData.gridTailPtrs[data0] == NULL) //Does this rows linked list have any nodes?
                        {
                            //This is the first node to be added to this 
                            //row so no need to consider the previous node when
                            //calulating the column number of the node to be added
                            columnNum = (currentDeltaTime / ((sequencer_ppqn*4) / sequencer_quantization));
                        }
                        else
                        {
                            //This rows linked list has existing nodes
                            if(sequencerGridData.gridTailPtrs[data0]->prevPtr != NULL) 
                            {
                                //Calulate grid number of new node to be added 
                                //considering the grid number of the previous node
                                columnNum = sequencerGridData.gridTailPtrs[data0]->prevPtr->column + (currentDeltaTime / sequencer_ppqn);
                            }
                        }

                        gridLinkedListAppendNote(columnNum, statusByte, data0, data1, 0, false); //--- CREATE NEW LINKED LIST NODE ---//

                        //modify the new grid item to become a note-off event
                        sequencerGridData.gridTailPtrs[data0]->statusByte = (0x80 | (0x0F & statusByte));
                        sequencerGridData.gridTailPtrs[data0]->rgbColourCode = rgb_off;
                        sequencerGridData.gridTailPtrs[data0]->dataBytes[0] = data0;
                        sequencerGridData.gridTailPtrs[data0]->dataBytes[1] = data1;
                        sequencerGridData.gridTailPtrs[data0]->deltaTime = currentDeltaTime;
                        sequencerGridData.gridTailPtrs[data0]->column = columnNum;
       

                        if(sequencerGridData.gridTailPtrs[data0]->column > totalColumnCount) totalColumnCount = sequencerGridData.gridTailPtrs[data0]->column;

                        //ESP_LOGI(LOG_TAG, "column: %d", sequencerGridData.gridTailPtrs[data0]->column);
                    }
                        
                    ESP_LOGI(LOG_TAG, "note_off channel=%0x, note=%d, time=%ld", (0x0F & statusByte), *(midiFileDataPtr+1), currentDeltaTime);                        
                    
                    break;




                        if(sequencerGridData.gridTailPtrs[data0] == NULL) //Does this rows linked list have any nodes?
                        {
                            //This is the first node to be added to this 
                            //row so no need to consider the previous node when
                            //calulating the column number of the node to be added
                            if(totalColumnCount > 1) columnNum = totalColumnCount + (currentDeltaTime / ((sequencer_ppqn*4) / sequencer_quantization));
                            else columnNum = (currentDeltaTime / ((sequencer_ppqn*4) / sequencer_quantization));
                        }
                        else
                        {
                            //This rows linked list has existing nodes
                            if(sequencerGridData.gridTailPtrs[data0]->prevPtr != NULL) 
                            {
                                //Calulate grid number of new node to be added 
                                //considering the grid number of the previous node
                                columnNum = totalColumnCount + (currentDeltaTime / ((sequencer_ppqn*4) / sequencer_quantization));
                            }
                            else ESP_LOGE(LOG_TAG, "Error: Unexpected NULL ptr");
                        }                    

            // When starting a new project, or opening an existing project the
            // sequencer grid needs to be reset to its initial (blank) state
            resetSequencerGrid(MIDI_SEQUENCER_PPQ, 4);

            // addNoteToGrid(4, 0x90, 0x36, 60, 1, true);
            // addNoteToGrid(3, 0x90, 0x37, 60, 1, true);

            // addNoteToGrid(2, 0x90, 0x36, 60, 1, true);
            // addNoteToGrid(1, 0x90, 0x37, 60, 1, true);


            addNoteToGrid(5, 0x90, 0x37, 60, 1, true);
            addNoteToGrid(4, 0x90, 0x36, 60, 1, true);

            //addNoteToGrid(3, 0x90, 0x36, 60, 1, true);
            //addNoteToGrid(2, 0x90, 0x37, 60, 1, true);

            addNoteToGrid(6, 0x90, 0x37, 60, 1, true);
            addNoteToGrid(6, 0x90, 0x36, 60, 1, true);

            addNoteToGrid(1, 0x90, 0x36, 60, 1, true);
            addNoteToGrid(0, 0x90, 0x37, 60, 1, true);

            addNoteToGrid(7, 0x90, 0x37, 60, 1, true);
            addNoteToGrid(7, 0x90, 0x36, 60, 1, true);

            addNoteToGrid(20, 0x90, 0x37, 60, 1, true);
            addNoteToGrid(28, 0x90, 0x37, 60, 1, true);


            updateGridLEDs(0x34, 0);
            vTaskDelay(pdMS_TO_TICKS(3000));

            vTaskDelay(1); // Smash idle

            projectParams.midiFileSizeBytes = gridDataToMidiFile((uint8_t *)(midiFileDataCacheBASE + MIDI_FILE_TRACK_HEADER_OFFSET));
            projectParams.midiFileSizeBytes += MIDI_FILE_TRACK_HEADER_OFFSET + 8;

            printEntireMidiFileContentToConsole(midiFileDataCacheBASE, projectParams.midiFileSizeBytes);

            fileSys_writeFile(projectParams.fileName, midiFileDataCacheBASE, projectParams.midiFileSizeBytes, false);

            fileSys_readFile(projectParams.fileName, midiFileDataCacheBASE, projectParams.midiFileSizeBytes, true);

            printEntireMidiFileContentToConsole(midiFileDataCacheBASE, projectParams.midiFileSizeBytes);

            vTaskDelay(1); // Smash idle

            ESP_LOGI(LOG_TAG, "Executing midiFiletoGrid processing");

            midiFileToGrid(midiFileDataCacheBASE + MIDI_FILE_TRACK_HEADER_OFFSET + 8);

            vTaskDelay(1); // Smash idle

            ESP_LOGI(LOG_TAG, "Update sequencer grid LEDS");

            updateGridLEDs(0x34, 0);

            projectParams.midiFileSizeBytes = gridDataToMidiFile((uint8_t *)(midiFileDataCacheBASE + MIDI_FILE_TRACK_HEADER_OFFSET));
            projectParams.midiFileSizeBytes += MIDI_FILE_TRACK_HEADER_OFFSET + 8;

            printEntireMidiFileContentToConsole(midiFileDataCacheBASE, projectParams.midiFileSizeBytes);