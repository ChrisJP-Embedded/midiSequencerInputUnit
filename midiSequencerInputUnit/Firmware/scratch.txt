//This function updates all rgbs leds of the switch matrix 

    SequencerGridItem_t * tempPtr = NULL;
    SequencerGridItem_t * searchPtr = NULL;
    bool abortCurrentRow = false;
    bool runOncePerRow = false;
    uint16_t numGridSteps = 0;
    uint8_t relativeRow = 0;
    uint16_t relativeColumn = 0;
    rgbLedColour_t gridRGBCodes[48] = {rgb_off};

    //This system uses an array of linked lists, one for each of the possible 128 midi notes.
    //Each of these linked lists hold data for one row of the sequencer grid matrix data.
    //The number of columns in the sequencer grid martrix is dynamic, growing with the project.

    //The pysical hardware grid is a matrix of 48 switches, made up of 6 rows of 8 columns
    //Each switch has its own assosiated RGB led, this function controlls the led driver for the hardware grid.

    //As the physical grid is limited in size, only a 6x8 'window'
    //of the larger 128xN (N = dynamic num columns) can be displayed

    //The input arguments 'rowOffset' and 'columnOffset' and relative to 0x0 on the physical grid.

    //Example: rowOffset = 5, columnOffset = 8.
    //The physical hardware grid will be displaying rows 5 -> 10 and columns 8 -> 15.
    //The code below look look for event nodes that have grid coordinates within that
    //window, setting rgb colours as appropriate (each node has an rgbColour member)

    for(uint8_t idx = rowOffset; idx < (rowOffset + NUM_SEQUENCER_HARDWARE_ROWS + 1); ++idx)
    { 
        runOncePerRow = true; //set flag for current row

        if(g_GridData.gridLinkedListHeadPtrs[idx] != NULL)
        {
            //We get here is the linked list for the current
            //row has at least one or more event nodes.

            if(g_GridData.gridLinkedListTailPtrs[idx] == NULL)
            {
                //Shouldn't be possible under normal operation
                ESP_LOGE(LOG_TAG, "Error: Unexpected NULL ptr in 'updateGridLEDs'");
                return;
            }

            //Now we need to find out if any of the list nodes,
            //fall within the column range speicifed by 'columnOffset'

            //If TRUE this linked list may contain event nodes which
            //fall within the target window and will need to be searched
            if(g_GridData.gridLinkedListTailPtrs[idx]->column >= columnOffset)
            {
                tempPtr = g_GridData.gridLinkedListHeadPtrs[idx];

                //Now search for first event node to fall within window, if one exists
                findEventsWithinWindow:

                //If TRUE, the event node pointed at by tempPtr DOES NOT fall within the target window
                if((tempPtr->column >= columnOffset) && (tempPtr->column < columnOffset + NUM_GRID_COLUMNS_PER_ROW) == false)
                {
                    if(tempPtr->nextPtr !=  NULL)
                    {
                        //current node coordinates didnt fall within
                        //target window so move onto next node in the list
                        tempPtr = tempPtr->nextPtr;
                        goto findEventsWithinWindow;
                    }
                    else
                    {
                        //end of linked list
                        abortCurrentRow = true;
                    }
                }
                //The end of the list hasnt been reached, but we are no longer within the target window
                else if(tempPtr->column > (columnOffset + NUM_GRID_COLUMNS_PER_ROW)) abortCurrentRow = true;

                if(!abortCurrentRow)
                {
                    //We reach here if a target node has been found 
                    //to exist within the specified grid window

                    //If everything worked 'tempGridItemPtr' should now be pointing to the first
                    //item for the specified row that falls within the target grid area. There
                    //may be a single item or multiple items that fall within the target grid area

                    //remove offset to get zero base hardware column num
                    relativeColumn = tempPtr->column - columnOffset;
        
                    if((CLEAR_LOWER_NIBBLE(tempPtr->statusByte) == MIDI_NOTE_OFF_MSG) && (tempPtr->column > columnOffset) && (runOncePerRow))
                    {
                        //We only get here when the first event node in the current linked list is a note off event
                        //while note-off events are not themselves displayed, if the relativeColumn is greater than zero
                        //it means we have an existing note duration that overruns into the target window.
                        //Any grid steps that are a note duration overrun must be displayed.
                        runOncePerRow = false;
                        numGridSteps = tempPtr->column - columnOffset;

                        for(uint8_t a = 0; a <= numGridSteps; ++a)
                        {
                            //Set the colour of the grid coordinates that make up the note duration overrun
                            gridRGBCodes[0 + (relativeRow * NUM_GRID_COLUMNS_PER_ROW) + a] = rgb_green;
                        }
                    }
                    else if(CLEAR_LOWER_NIBBLE(tempPtr->statusByte) == MIDI_NOTE_ON_MSG)
                    {
                        //A note-on event has been found within the target window
                        //we must now find the duration of that note off event in steps
                        runOncePerRow = false;
                        //Search for and get pointer to corresponding note-off
                        searchPtr = getPointerToCorespondingNoteOffEventNode(tempPtr);
                        if(searchPtr != NULL) 
                        {
                            //We get here if the corresponding note-off to 
                            //the current note-on event has been found to exist
                            numGridSteps = searchPtr->column - tempPtr->column;
                        }
                        else
                        {
                            //Couldnt find corresponding note off event (SHOULD NOT REACH HERE)
                            numGridSteps = 1; //illuminate the coordinate of the note-on event itself
                            ESP_LOGE(LOG_TAG, "Error: Unable to find expected corresponding note-off in 'updateGridLEDs'");
                        } 

                        for(uint8_t a = 0; a < numGridSteps; ++a)
                        {
                            //Set the colour of the grid coordinates that make up the current notes duration
                            gridRGBCodes[relativeColumn + (relativeRow * NUM_GRID_COLUMNS_PER_ROW) + a] = rgb_green;
                        }

                        tempPtr = searchPtr;
                    }

                    if(tempPtr->nextPtr !=  NULL)
                    {
                        //Still more nodes to process
                        tempPtr = tempPtr->nextPtr;
                        goto findEventsWithinWindow;
                    }
                }
            }
        }
        abortCurrentRow = false; //reset flag for next row
        ++relativeRow; //Increment zero offset hardware row
    }

    ledDrivers_writeEntireGrid(gridRGBCodes);
    for(uint8_t a = 0; a < 48; ++a)
    {
        ESP_LOGI(LOG_TAG, "Rgb grid code: %0x", gridRGBCodes[a]);
    }