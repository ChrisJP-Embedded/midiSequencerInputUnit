
static uint8_t appendNewGridData(uint16_t columnNum, uint8_t statusByte, uint8_t midiNoteNumber, uint8_t midiVelocity, uint8_t durationInSteps, bool autoAddNoteOff)
{
    assert(midiNoteNumber < TOTAL_MIDI_NOTES);

    SequencerGridItem_t * newEventNodePtr = NULL;

    newEventNodePtr = createNewEventNode(statusByte, columnNum, midiNoteNumber, midiVelocity, rgb_green);
    genericDLL_appendNewNodeOntoLinkedList(newEventNodePtr, &g_GridData.gridLinkedListHeadPtrs[midiNoteNumber], &g_GridData.gridLinkedListTailPtrs[midiNoteNumber]);


    //Update a record of the total columns in the project
    if(columnNum > g_GridData.totalGridColumns) g_GridData.totalGridColumns = columnNum;

    if(autoAddNoteOff) addCorrespondingNoteOff(newEventNodePtr, durationInSteps);

    return 0; 
}


static uint8_t insertNewGridData(uint16_t columnNum, uint8_t statusByte, uint8_t midiNoteNumber, 
                                        uint8_t midiVelocity, uint8_t durationInSteps, bool autoAddNoteOff)
{
    //This newly inputed grid entry occurs BEFORE the current last
    //item in the linked list for the current row/note, we therefore need
    //to find the correct location in the linked list and manually insert,
    //ensuring that all pointers are updated correctly

    assert(midiNoteNumber < TOTAL_MIDI_NOTES);
    assert(g_GridData.gridLinkedListTailPtrs[midiNoteNumber] != NULL);

    SequencerGridItem_t * tempNodePtr = NULL;
    SequencerGridItem_t * newEventNodePtr = NULL;

    tempNodePtr = g_GridData.gridLinkedListTailPtrs[midiNoteNumber];

    if(doesThisGridCoordinateFallWithinAnExistingNoteDuration(columnNum, midiNoteNumber))
    {
        ESP_LOGI(LOG_TAG, "Error: Cant place note within existing notes duration");
        return 1;
    }

    while(tempNodePtr != NULL)
    {
        //ADD TIMEOUT
        if(tempNodePtr->column <= columnNum) break;
        if(tempNodePtr->prevPtr == NULL)
        {
            tempNodePtr = NULL;
            break;
        } 
        tempNodePtr = tempNodePtr->prevPtr;
    }

    //We get here if this new event node needs to be inserted at the list head 
    //this means that the global list head ptr array will also need updating
    newEventNodePtr = createNewEventNode(statusByte, columnNum, midiNoteNumber, midiVelocity, rgb_green);
    genericDLL_insertNewNodeIntoLinkedList(newEventNodePtr, tempNodePtr, &g_GridData.gridLinkedListHeadPtrs[midiNoteNumber]);
    tempNodePtr = newEventNodePtr;

    if(autoAddNoteOff) addCorrespondingNoteOff(newEventNodePtr, durationInSteps);

    return 0;
}









void updateGridLEDs(uint8_t rowOffset, uint16_t columnOffset)
{
    //This function updates all rgbs leds of the switch matrix 

    SequencerGridItem_t * tempNodePtr = NULL;
    SequencerGridItem_t * searchPtr = NULL;
    bool abortCurrentRow = false;
    bool runOncePerRow = false;
    uint16_t numGridSteps = 0;
    uint8_t relativeRow = 0;
    uint16_t relativeColumn = 0;
    rgbLedColour_t gridRGBCodes[48] = {rgb_off};

    bool keepSearchingCurrentRow = false;

    //The pysical sequencer grid is made up of a matrix of switches, where each
    //switch has its own assosiated RGB led, this function handles the setting
    //of those RGB leds in order to provide a means to display grid data.

    //The pysical size of the grids switch matrix is defined by:
    //NUM_SEQUENCER_PHYSICAL_ROWS x NUM_SEQUENCER_PHYSICAL_COLUMNS
    //The top left switch of the grid considered as coordinate 0,0.

    //The grid data that can be displayed is limited to the physical size of
    //the sequencer grid. Depending on the sequence, its likely that it will
    //only be possible to display a subset of the virtual grid at any one time.

    //The input arguments 'rowOffset' and 'columnOffset' allow the caller to
    //specify which area of grid data should be displayed on the physical grid.

    //EXAMPLE: rowOffset = 5, columnOffset = 7.
    //The physical grid will display any events which fall 
    //within the following area of the virtual grid data.
    //Rows:    5 -> (5 + (NUM_SEQUENCER_PHYSICAL_ROWS - 1))
    //Columns: 7 -> (7 + (NUM_SEQUENCER_PHYSICAL_COLUMNS - 1))


    //Iterate through each grid row that fall within the specified area. Each row 
    //stores midi events as nodes in a linked list. A row may have zero or more event nodes.
    for(uint8_t rowNum = rowOffset; rowNum <= (rowOffset + NUM_SEQUENCER_PHYSICAL_ROWS); ++rowNum)
    { 
        runOncePerRow = true;
        abortCurrentRow = false;

        //We only need to do further processing for the 
        //current row if has midi events allocated to it 
        if(g_GridData.gridLinkedListHeadPtrs[rowNum] != NULL)
        {

            //A NULL pointer here indcates a system fault
            assert(g_GridData.gridLinkedListTailPtrs[rowNum] != NULL);

            //If the column of the last event node in the current rows list is LESS 
            //than the columnOffset no further processing is required for the current row
            if(g_GridData.gridLinkedListTailPtrs[rowNum]->column >= columnOffset)
            {
                //Grab a direct ptr to current rows linked list
                tempNodePtr = g_GridData.gridLinkedListHeadPtrs[rowNum];

                do
                {
                    keepSearchingCurrentRow = false;

                    //If condition evaulates to TRUE the event node pointed at by tempNodePtr DOES NOT fall within the target window
                    if((tempNodePtr->column >= columnOffset) && (tempNodePtr->column < columnOffset + NUM_SEQUENCER_PHYSICAL_COLUMNS) == false)
                    {
                        //Check if more nodes exist
                        if(tempNodePtr->nextPtr !=  NULL)
                        {
                            //current node coordinates didnt fall within
                            //target window so move onto next node in the list
                            tempNodePtr = tempNodePtr->nextPtr;
                            //goto findEventsWithinWindow;
                            keepSearchingCurrentRow = true;
                        }
                        else
                        {
                            //end of linked list
                            abortCurrentRow = true;
                        }
                    }
                    //The end of the list hasnt been reached, but we are no longer within the target window
                    else if(tempNodePtr->column > (columnOffset + NUM_SEQUENCER_PHYSICAL_COLUMNS)) abortCurrentRow = true;

                    if(!abortCurrentRow)
                    {
                        //We reach here if a target node has been found 
                        //to exist within the specified grid window

                        //If everything worked 'tempGridItemPtr' should now be pointing to the first
                        //item for the specified row that falls within the target grid area. There
                        //may be a single item or multiple items that fall within the target grid area

                        //remove offset to get zero base hardware column num
                        relativeColumn = tempNodePtr->column - columnOffset;
            
                        if((CLEAR_LOWER_NIBBLE(tempNodePtr->statusByte) == MIDI_NOTE_OFF_MSG) && (tempNodePtr->column > columnOffset) && (runOncePerRow))
                        {
                            //We only get here when the first event node in the current linked list is a note off event
                            //while note-off events are not themselves displayed, if the relativeColumn is greater than zero
                            //it means we have an existing note duration that overruns into the target window.
                            //Any grid steps that are a note duration overrun must be displayed.
                            runOncePerRow = false;
                            numGridSteps = tempNodePtr->column - columnOffset;

                            for(uint8_t a = 0; a <= numGridSteps; ++a)
                            {
                                //Set the colour of the grid coordinates that make up the note duration overrun
                                gridRGBCodes[0 + (relativeRow * NUM_SEQUENCER_PHYSICAL_COLUMNS) + a] = rgb_green;
                            }
                        }
                        else if(CLEAR_LOWER_NIBBLE(tempNodePtr->statusByte) == MIDI_NOTE_ON_MSG)
                        {
                            //A note-on event has been found within the target window
                            //we must now find the duration of that note off event in steps
                            runOncePerRow = false;
                            //Search for and get pointer to corresponding note-off
                            searchPtr = getPointerToCorespondingNoteOffEventNode(tempNodePtr);
                            if(searchPtr != NULL) 
                            {
                                //We get here if the corresponding note-off to 
                                //the current note-on event has been found to exist
                                numGridSteps = searchPtr->column - tempNodePtr->column;
                            }
                            else
                            {
                                //A system fault has been detected if we reach here
                                ESP_LOGE(LOG_TAG, "Error: Unable to find expected corresponding note-off in 'updateGridLEDs'");
                                assert(0);
                            } 

                            for(uint8_t a = 0; a < numGridSteps; ++a)
                            {
                                //Set the colour of the grid coordinates that make up the current notes duration
                                gridRGBCodes[relativeColumn + (relativeRow * NUM_SEQUENCER_PHYSICAL_COLUMNS) + a] = rgb_green;
                            }

                            tempNodePtr = searchPtr;
                        }

                        if(tempNodePtr->nextPtr !=  NULL)
                        {
                            //Still more nodes to process
                            tempNodePtr = tempNodePtr->nextPtr;
                            keepSearchingCurrentRow = true;
                        }
                    }               

                }while(keepSearchingCurrentRow);
            }
        }
        ++relativeRow; //Increment zero offset hardware row
    }

    ledDrivers_writeEntireGrid(gridRGBCodes);
}