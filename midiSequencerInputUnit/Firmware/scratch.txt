
uint8_t generateEmptyMidiFile(uint8_t * filePtr, uint16_t ppq, uint8_t tempo)
{
    //This function expects a pointer to a file buffer,
    //it will write a default midi file template with a
    //single track that contains a single midi event,
    //an EOF meta event.
    
    //TODO: Add tempo meta message (currentlY)

    if(filePtr == NULL) return 0;

    uint8_t writeAddr = 0;

    //Write midi file header (4 bytes)
    for(uint8_t a = 0; a < sizeof(MThd_fileHeaderBytes); ++a)
    {
        filePtr[writeAddr++] = MThd_fileHeaderBytes[a];
    }

    //Write header length (4 bytes - always equal to 6)
    filePtr[writeAddr++] = 0;
    filePtr[writeAddr++] = 0;
    filePtr[writeAddr++] = 0;
    filePtr[writeAddr++] = 6;

    //Write format (2 bytes - always format 0 - single track format)
    filePtr[writeAddr++] = 0;
    filePtr[writeAddr++] = 0;

    //Write number of tracks that follow (2 bytes - always equal 1 for format 0)
    filePtr[writeAddr++] = 0;
    filePtr[writeAddr++] = 1;

    //Write division (ppq) (2 bytes)
    filePtr[writeAddr++] = (uint8_t)(ppq >> 8);
    filePtr[writeAddr++] = (uint8_t)(ppq);

    //Write midi track header (4 bytes)
    for(uint8_t a = 0; a < sizeof(MTtk_trackHeaderBytes); ++a)
    {
        filePtr[writeAddr++] = MTtk_trackHeaderBytes[a];
    }

    //Write track length in bytes (4 bytes)
    filePtr[writeAddr++] = 0;
    filePtr[writeAddr++] = 0;
    filePtr[writeAddr++] = 0;
    filePtr[writeAddr++] = 4;

    //Write end of track meta message
    //with a delta time of zero
    filePtr[writeAddr++] = 0;
    filePtr[writeAddr++] = 0xFF;
    filePtr[writeAddr++] = 0x2F;
    filePtr[writeAddr++] = 0x00;

    return writeAddr;
}


uint8_t getDeltaTimeVaraibleLengthNumBytes(uint32_t deltaTime)
{
    //This function takes in a 32-bit deltaTime value
    //and returns the number of bytes required to 
    //represent it in when converted to a variable length
    //value (as a delta times appear in a midi file)

    //Note: Check the returned value is within range.
    
    unsigned char count = 1;
    while(deltaTime >>= 7)
    {
        ++count;
    } 
    return count;
}


uint8_t getDeltaTimeVaraibleLengthNumBytes(uint32_t deltaTime)
{
    //This function takes in a 32-bit deltaTime value
    //and returns the number of bytes required to 
    //represent it in when converted to a variable length
    //value (as a delta times appear in a midi file)
    
    assert(deltaTime <= MIDI_FILE_MAX_DELTA_TIME_VALUE);

    //Delta-time min one byte
    unsigned char count = 1;
    while(deltaTime >>= (NUM_BITS_IN_BYTE - 1))
    {
        ++count;
    } 
    return count;
}


uint32_t processMidiFileDeltaTime(uint8_t * midiFilePtr)
{
    //This function processes a midi file delta time,
    //it expects a pointer to the base of a delta time

    //This function is called when converting an
    //existing midi file to grid data.

    //A delta-time is variable length value, between 1 and 4 
    //bytes in length, it specifies (in midi ticks) the time
    //that must pass before the event it is assosiated with
    //should be transmitted.

    //Delta-time bytes appear in MSB first order, the MSBIT
    //in each byte is a flag which indicates that there are
    //more delta-time bytes to follow when SET.
    //To generate the reconstructed value, the MSBIT of each
    //delta-time byte is removed and then remaining 7 bits of
    //each byte are concatenated.

    //RETURNS: The reconstructed 32-bit (max) delta-time value.

    assert(midiFilePtr != NULL);

    uint32_t tempStore = 0;
    uint32_t result = 0;
    uint8_t numBytes = 0;
    bool hasBytesToRead = true;

    while(hasBytesToRead)
    {
        hasBytesToRead = false; //May only have a single byte
        tempStore |= *midiFilePtr; //Get first delta-time byte

        //If MSBIT is SET then delta-time has more bytes
        if(GET_MSBIT_IN_BYTE(*midiFilePtr)) 
        {
            //We get here if bit 8 of the current delta-time byte
            //is SET (meaning at least one more delta-time byte)

            //Delta-times are FOUR BYTES max in length
            if(numBytes < MIDI_FILE_MAX_DELTA_TIME_NUM_BYTES) 
            {
                tempStore <<= NUM_BITS_IN_BYTE;
                ++numBytes;
                midiFilePtr += 1;
                hasBytesToRead = true;
            }
        }
    }

    //Finished reading all bytes from file,
    //now need to decode delta-time bytes
    //into final delta-time value.
    for (uint8_t a = 0; a <= numBytes; ++a)
    {
        //For each delta-time byte we need to remove bit 8 and concatenate the result
        result |= ((tempStore & (0x0000007F << (a * NUM_BITS_IN_BYTE))) >> ((a ? 1 : 0) * a));
    }

    return result;
}



int8_t processMidiFileMetaMessage(uint8_t * metaMsgPtr)
{
    //This function processes a midi file meta message,
    //it expects a pointer to the base of a meta message

    //This function is called when converting 
    //an existing midi file to grid data. 

    //A meta message has the follow byte structure:
    //meta_message[0] = 0xFF (indicates meta message)  <- *metaMsgPtr
    //meta_message[1] = meta status byte
    //meta_message[2] = length byte (number of bytes that follow)
    
    //RETURNS:

    //ON SUCCESS: the length of the meta message (an EOF meta
    //message is the only meta message with a length of zero)

    //ON FAILURE: if the meta message is not recognized the
    //return value will be -1, indicating corrupt data.


    assert(metaMsgPtr != NULL);
    assert(*metaMsgPtr == 0xFF);

    uint8_t metaMsgLengthInBytes;
    uint8_t metaStatusByte;

    metaMsgPtr += 1;
    metaStatusByte = *metaMsgPtr;
    metaMsgPtr += 1; 
    metaMsgLengthInBytes = *metaMsgPtr;


    //Check meta message status byte
    switch (metaStatusByte)
    {
        case metaEvent_deviceName:
            ESP_LOGI(LOG_TAG, "metaEvent_deviceName detected");
            break;

        case metaEvent_midiPort:
            ESP_LOGI(LOG_TAG, "metaEvent_midiPort detected");
            break;

        case metaEvent_sequenceNum:
            //Two data bytes expected
            ESP_LOGI(LOG_TAG, "metaEvent_sequenceNum detected");
            break;

        case metaEvent_cuePoint:
        case metaEvent_marker:
        case metaEvent_lyrics:
        case metaEvent_instrumentName:
        case metaEvent_trackName:
        case metaEvent_copyright:
        case metaEvent_textField:
            //All meta events of variable length
            //Not bothered about any of these so just increment file pointer
            ESP_LOGI(LOG_TAG, "Ignored variable-length meta message");
            break;

        case metaEvent_channelPrefix:
            //Single data byte expected
            ESP_LOGI(LOG_TAG, "metaEvent_channelPrefix detected");
            break;

        case metaEvent_endOfTrack:
            //Single byte
            ESP_LOGI(LOG_TAG, "metaEvent_endOfTrack detected");
            break;

        case metaEvent_setTempo:
            //Three data bytes expected
            ESP_LOGI(LOG_TAG, "metaEvent_setTempo detected");
            break;

        case metaEvent_smpteOffset:
            //Five data bytes expected
            ESP_LOGI(LOG_TAG, "metaEvent_smpteOffset detected (not supported)");
            break;

        case metaEvent_setTimeSig:
            //Four data bytes expected
            ESP_LOGI(LOG_TAG, "metaEvent_setTimeSig detected");
            break;

        case metaEvent_keySignature:
            //Two data bytes expected
            ESP_LOGI(LOG_TAG, "metaEvent_keySignature detected");
            break;

        case metaEvent_sequencerSpecific:
            //Custom meta messages for the sequencer
            //Variable length
            ESP_LOGE(LOG_TAG, "metaEvent_sequencerSpecific detected");
            break;

        default:
            ESP_LOGE(LOG_TAG, "Error: Unrecognized meta message status byte");
            return -1; //Corrupt data detected
            break;
    }

    return metaMsgLengthInBytes;
}